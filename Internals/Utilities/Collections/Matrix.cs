using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Yours.QuickCity.Shape;

namespace Yours.QuickCity.Internal
{
    internal sealed class Matrix<TData> where TData : IMatrixNodeData, new()
    {
        private readonly MatrixNode<TData>[,] _nodes;
        private readonly Coord? _startPoint = null;

        // properties
        internal MatrixNode<TData> this[int x, int y] 
            => _nodes[x, y] ?? throw new System.Exception("invalid coord.");
        internal IEnumerable<MatrixNode<TData>> Content
        {
            get
            {
                for (int i = 0; i < _nodes.GetLength(0); i++)
                    for (int j = 0; j < _nodes.GetLength(1); j++)
                        if (_nodes[i, j] != null)
                            yield return _nodes[i, j];
            }
        }       

        /// <summary>
        /// number of node that closed, which are not <br/>
        /// connected to other area.
        /// </summary>
        /// <remarks>
        /// theoretically, the diagram-generator-progrom  <br/>
        /// will not produce such area. but it still may  <br/>
        /// generated by other program, such as structure <br/>
        /// generator etc.
        /// </remarks>
        internal int ClosedNodeNum { get; set; } = 0;
        private int RectangleSizeX => _nodes.GetLength(0);
        private int RectangleSizeY => _nodes.GetLength(1);

        /*
         *  constructors

         *  methods that used to init the diagram.
         */

        internal Matrix(IShape shape, float sizeMultiple)
        {
            var matrix = shape.GenerateShapeMatrix(sizeMultiple);

            var (sz_x, sz_y) = IShape.SizeOf(matrix);

            _nodes = new MatrixNode<TData>[sz_x, sz_y];

            for (int x = 0; x < sz_x; x++)
            {
                for (int y = 0; y < sz_y; y++)
                {
                    if (matrix[x, y])
                    {
                        if (_startPoint == null)
                            _startPoint = new Coord(x, y);
                        _nodes[x, y] = new() { Coordinate = new(x, y) };
                    }
                }
            }
        }

        /*
         *  core functions
         *  
         *  methods that carry the core function in diagram,
         *  which play important effects on map algorithm.
         */

        /// <summary>
        /// calculate if the input coordinate can place <br/>
        /// an obstacle with no influence on graph-connection.
        /// </summary>
        /// <param name="coord">coordinate to judge</param>
        /// <returns>true if input coordinate is placeable.</returns>
        internal bool StillConnectedWhenContented(Coord coord)
        {
            // Summary: 

            // This function will do following things to calculate:

            // First, it made an assumption that [targetCoord] IS 
            // an obstacle, and mark the center point of the map as
            // the program [beginning point].

            // Then, begin on the [begining point], program will
            // startup an ergodic for all tiles in the map, with
            // counting the number of accessible tile.

            // After the ergodic, program compares the truly number
            // of accessible tile with the numbers of it should be
            // (provides by map properties, calculate by total map
            // tile number and obstacle percentage.)

            // If those 2 numbers are equals, our assumption is
            // hold. which means, we can indeed do put an obstacle
            // without any accessible problem.

            // In that case, function will return TRUE.

            if (CoordIsOutOfBounds(coord))
                return false;

            # region Properties Define

            // storage current data as template.
            // by this, program can execute without modify actual data.
            var currentObsExistMap = GetObstacleDiagram();
            int currentObsNum = GetCurrentObstacleNum();
           
            // count of accessible tile.
            // by compare this value with ideal count, we can get the result.
            int accessibleTileCount = 0;

            // sign checked coord.
            bool[,] mapCheckedFlags = new bool[this.RectangleSizeX, this.RectangleSizeY];
            Queue<Coord> checkedCoords = new();

            #endregion

            #region Program

            // init, mark center point as accessible and start
            SignCoordAsAccessible((Coord)_startPoint);

            // posit current input coord is obstacle.
            PositCurrentTileIsObs();

            // check every point in the map.
            // for each point, check accessiblely of its neighbor(x+-1, y+-1).
            while (checkedCoords.Count > 0)
            {
                var currentTileCoord = checkedCoords.Dequeue();

                for (int x = -1; x <= 1; x++)
                {
                    for (int y = -1; y <= 1; y++)
                    {
                        Coord neighbor = new(
                            currentTileCoord.x + x,
                            currentTileCoord.y + y
                        );

                        if ((x != 0 && y != 0) || CoordIsOutOfBounds(neighbor))
                            continue;

                        if (mapCheckedFlags[neighbor.x, neighbor.y] || currentObsExistMap[neighbor.x, neighbor.y])
                            continue;

                        SignCoordAsAccessible(neighbor);
                    }
                }
            }

            // calculate if the assumption holds, return the result.
            return CalculateAccessible();

            #endregion

            #region Local Functions

            // process func
            void PositCurrentTileIsObs()
            {
                currentObsExistMap[coord.x, coord.y] = true;
                currentObsNum++;
            }
            void SignCoordAsAccessible(Coord target)
            {
                mapCheckedFlags[target.x, target.y] = true;
                accessibleTileCount++;
                checkedCoords.Enqueue(target);
            }
            
            // temp property getter
            int GetCurrentObstacleNum()
            {
                int num = 0;

                foreach (var node in this.Content)
                    if (node.Data.HasContent)
                        num++;

                return num;
            }
            bool[,] GetObstacleDiagram()
            {
                bool[,] diagram = new bool[this.RectangleSizeX, this.RectangleSizeY];

                foreach (var node in this.Content)
                    if (node != null && node.Data.HasContent)
                        diagram[node.Coordinate.x, node.Coordinate.y] = true;

                return diagram;
            }

            // result calculator
            bool CalculateAccessible()
            {
                // get ideal
                int idealAccessibleCount = this.Content.Count() - this.ClosedNodeNum - currentObsNum;
                return accessibleTileCount == idealAccessibleCount;
            }

            #endregion
        }

        /// <summary>
        /// judge if given coorinate is out of diagram node array's length.
        /// </summary>
        /// <param name="targetCoord"></param>
        /// <returns><see langword="true"/> if out of range.</returns>
        internal bool CoordIsOutOfBounds(Coord targetCoord)
        {
            return (targetCoord.x < 0 || targetCoord.x >= this.RectangleSizeX)
                   ||
                   (targetCoord.y < 0 || targetCoord.y >= this.RectangleSizeY)
                   ||
                   (_nodes[targetCoord.x, targetCoord.y] == null);
        }

        /// <summary>
        /// print debug info as unicode graph on console.
        /// </summary>
        internal void PrintDebugGraph()
        {
            System.Text.StringBuilder msg = new();
            MatrixNode<TData> node = null;

            for (int x = 0; x < this.RectangleSizeX; x++)
            {
                for (int y = 0; y < this.RectangleSizeX; y++)
                {
                    try
                    {
                        node = _nodes[x, y];
                    } 
                    catch (System.IndexOutOfRangeException) { }
                    
                    msg.Append(GetGridOutputMsg(node) + " ");
                }
                msg.Append("\n");
            }
            Debug.Log("地形示意图(z → x ↓): \n" + msg);

            static string GetGridOutputMsg(MatrixNode<TData> node)
            {
                if (node == null) return "▁";
                return node.Data.HasContent ? "■" : "□";
            }
        }
        
    }
}
